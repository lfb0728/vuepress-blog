# 单例模式

单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 

单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏 览器中的 window 对象等。在 JavaScript开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。 

## 实现单例模式 

​	要实现一个标准的单例模式并不复杂，无非是用一个变量来标志当前是否已经为某个类创建 过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。代码如下： 

```javascript
var Singleton = function( name ){    
    this.name = name;     
    this.instance = null; 
}; 
 
Singleton.prototype.getName = function(){     
    alert ( this.name ); 
}; 
 
Singleton.getInstance = function( name ){     
    if ( !this.instance ){         
        this.instance = new Singleton( name );    
    }    
    return this.instance;
}
var a = Singleton.getInstance( 'sven1' ); 
var b = Singleton.getInstance( 'sven2' ); 
 
alert ( a === b );    // true

// 或者： 
var Singleton = function( name ){     
    this.name = name; 
}; 
 
Singleton.prototype.getName = function(){    
    alert ( this.name ); 
}; 
 
Singleton.getInstance = (function(){    
    var instance = null;    
    return function( name ){        
        if ( !instance ){            
            instance = new Singleton( name );        
        }        
        return instance;     
    } 
})();
```

​		我们通过 Singleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但有 一个问题，就是增加了这个类的“不透明性”，Singleton 类的使用者必须知道这是一个单例类， 跟以往通过 new XXX 的方式来获取对象不同，这里偏要使用 Singleton.getInstance 来获取对象。 接下来顺便进行一些小测试，来证明这个单例类是可以信赖的：

```javascript
var a = Singleton.getInstance( 'sven1' ); 
var b = Singleton.getInstance( 'sven2' ); 
 
alert ( a === b );     // true 
```

## 透明的单例模式

​	我们现在的目标是实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使 用其他任何普通类一样。在下面的例子中，我们将使用 CreateDiv 单例类，它的作用是负责在页 面中创建唯一的 div 节点，代码如下：

```javascript
var CreateDiv = (function(){ 
 
    var instance; 
 
    var CreateDiv = function( html ){         
        if ( instance ){             
            return instance;         
        }         
        this.html = html;         
        this.init(); 
        return instance = this;     
    }; 
 
    CreateDiv.prototype.init = function(){         
        var div = document.createElement( 'div' );         
        div.innerHTML = this.html;         
        document.body.appendChild( div );     
    }; 
 
    return CreateDiv; 
 
})(); 
 
var a = new CreateDiv( 'sven1' ); 
var b = new CreateDiv( 'sven2' ); 
 
alert ( a === b );     // true
```

​	虽然现在完成了一个透明的单例类的编写，但它同样有一些缺点。 为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回 真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。 

观察现在的 Singleton 构造函数： 

```javascript
var CreateDiv = function( html ){     
    if ( instance ){         
        return instance;     
    }     
    this.html = html;     
    this.init();     
    return instance = this; 
}; 
```

​	在这段代码中，CreateDiv 的构造函数实际上负责了两件事情。第一是创建对象和执行初始 化 init 方法，第二是保证只有一个对象。虽然我们目前还没有接触过“单一职责原则”的概念， 但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。 假设我们某天需要利用这个类，在页面中创建千千万万的 div，即要让这个类从单例类变成 一个普通的可产生多个实例的类，那我们必须得改写 CreateDiv 构造函数，把控制创建唯一对象 的那一段去掉，这种修改会给我们带来不必要的烦恼。 

## 用代理实现单例模式 

现在我们通过引入代理类的方式，来解决上面提到的问题。 

首先在 CreateDiv 构造函数中，把负责管理单例的代码移除 出去，使它成为一个普通的创建 div 的类： 

```javascript
var CreateDiv = function( html ){    
    this.html = html;
    this.init(); 
}; 
 
CreateDiv.prototype.init = function(){    
    var div = document.createElement( 'div' );     
    div.innerHTML = this.html;     
    document.body.appendChild( div ); 
}; 
 //接下来引入代理类 proxySingletonCreateDiv： 
var ProxySingletonCreateDiv = (function(){ 
    var instance;    
    return function( html ){         
        if ( !instance ){            
            instance = new CreateDiv( html );         
        } 
 
        return instance;    
    } 
 
})(); 
 
var a = new ProxySingletonCreateDiv( 'sven1' ); 
var b = new ProxySingletonCreateDiv( 'sven2' ); 
 
alert ( a === b ); 
```

​	通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们 把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。这样一来，CreateDiv 就变成了 一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。 